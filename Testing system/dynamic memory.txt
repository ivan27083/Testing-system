№1 Что такое динамическая память в Си++?
1)Это память, выделенная на стеке;
2)Это память, выделенная автоматически при объявлении переменной;
3)Это память, которую выделяет программист по запросу;
4)Это память, выделяемая во время выполнения программы;*

№2 Как выделяется динамическая память в Си++?
1)С помощью оператора sizeof;
2)С помощью оператора new;
3)С помощью оператора malloc;*
4)С помощью оператора stack_alloc;

№3 Как освобождается динамическая память в Си++?
1)С помощью оператора sizeof;
2)С помощью оператора delete;
3)С помощью оператора free;*
4)С помощью оператора stack_free;

№4 Что произойдет, если не освободить выделенную динамическую память?
1)Программа будет утечка памяти;*
2)Программа завершится с ошибкой;
3)Выделенная память будет автоматически освобождена после завершения программы;
4)Выделенная память будет освобождена при следующем запуске программы;

№5 Какой тип данных возвращает оператор new?
1)Указатель на выделенную память;*
2)Целочисленное значение, равное размеру выделенной памяти в байтах;
3)Булево значение, указывающее, была ли память выделена успешно;
4)Оператор new не возвращает значение;

№6 Какой тип данных возвращает оператор malloc?
1)Указатель на выделенную память;*
2)Целочисленное значение, равное размеру выделенной памяти в байтах;
3)Булево значение, указывающее, была ли память выделена успешно;
4)Оператор malloc не возвращает значение;

№7 Какой тип данных принимает оператор delete?
1)Указатель на выделенную память;*
2)Целочисленное значение, равное размеру выделенной памяти в байтах;
3)Булево значение, указывающее, была ли память выделена успешно;
4)Оператор delete не принимает параметров;

№8 Какой тип данных принимает оператор free?
1)Указатель на выделенную память;*
2)Целочисленное значение, равное размеру выделенной памяти в байтах;
3)Булево значение, указывающее, была ли память выделена успешно;
4)Оператор free не принимает параметров;

№9 Как получить адрес выделенной динамичесой памяти в Си++?
1)Адрес выделяемой памяти возвращается оператором new или malloc;*
2)Адрес выделяемой памяти можно получить с помощью оператора & перед переменной, выделенной динамически;
3)Адрес выделяемой памяти можно получить с помощью оператора * перед указателем на выделенную память;
4)Адрес выделяемой памяти нельзя получить;

№10 Можно ли изменять размер выделенной динамической памяти?
1)Да, с помощью операторов realloc или new с новым размером;*
2)Нет, размер выделенной динамической памяти нельзя изменить;
3)Размер выделенной динамической памяти автоматически увеличивается при необходимости;
4)Размер выделенной динамической памяти может быть изменен только вручную, с помощью копирования данных в новую область памяти;

№11 Как проверить, была ли память успешно выделена операторами new или malloc?
1)С помощью оператора sizeof;
2)С помощью оператора & перед переменной, выделенной динамически;
3)С помощью проверки, что возвращенный указатель не равен нулю;*
4)Нет необходимости проверять успешность выделения памяти, так как операторы new и malloc всегда выделяют запрошенный объем памяти;

№12 Что произойдет, если запросить выделение памяти, больше чем доступно на компьютере?
1)Операторы new и malloc вернут нулевой указатель;*
2)Операторы new и malloc автоматически выделят дополнительную память на жестком диске;
3)Операторы new и malloc вызовут ошибку выполнения программы;
4)Операторы new и malloc уменьшат размер запрашиваемой памяти до максимально доступного размера;

№13 Может ли одна программа изменять память, выделенную другой программой?
1)Да, если программа запущена с правами администратора;
2)Нет, каждая программа работает в своем собственном адресном пространстве;*
3)Да, если память была выделена в общей памяти;
4)Нет, если память была выделена с помощью оператора new;

№14 Какие функции C++ STL можно использовать для работы с динамической памятью?
1)vector и map;
2)list и set;
3)vector и unique_ptr;*
d)map и shared_ptr;

№15 Что такое умный указатель в C++?
1)Это указатель, который может указывать на различные объекты, в зависимости от текущего контекста программы;
2)Это указатель, который автоматически освобождает выделенную память при выходе из области видимости;*
3)Это указатель, который может изменять свою адресацию в зависимости от изменения адресного пространства программы;
4)Это указатель, который позволяет получать доступ к переменным и объектам, объявленным в других функциях;

№16 Какой умный указатель следует использовать для выделения памяти под один объект?
1)unique_ptr;*
2)shared_ptr;
3)weak_ptr;
4)auto_ptr;

№17 Какой умный указатель следует использовать для выделения памяти под несколько объектов?
1)unique_ptr;
2)shared_ptr;*
3)weak_ptr;
4)auto_ptr;

№18 Какой метод класса unique_ptr следует использовать для получения указателя на выделенную память?
1)get();
2)release();
3)reset();
4)все перечисленные;

№19 Какой метод класса shared_ptr следует использовать для получения количества указателей, указывающих на выделенную память?
1)get();
2)count();
3)reset();
4)use_count();*

№20 Какой метод класса shared_ptr следует использовать для изменения объекта, на который указывает указатель?
1)get();
2)count();
3)reset();
4)нет верного ответа;*

№21 Каким образом следует передавать умный указатель в функцию, которая будет его использовать?
1)По значению;
2)По ссылке;*
3)По указателю;
4)Никак, умные указатели нельзя передавать в функции;

№22 Какой умный указатель следует использовать, если нужно передать указатель в функцию и не делать копию объекта?
1)unique_ptr;
2)shared_ptr;*
3)weak_ptr;
4)auto_ptr;

№23 Какой умный указатель следует использовать, если нужно передать указатель в функцию, но сохранить его вне области видимости функции?
1)unique_ptr;
2)shared_ptr;*
3)weak_ptr;
4)auto_ptr;

№24 Что произойдет, если попытаться скопировать объект класса unique_ptr?
1)Копирование будет выполнено успешно, но выделенная память будет освобождена только для одного из объектов;
2)Копирование вызовет ошибку компиляции;
3)Копирование запрещено, так как класс unique_ptr не поддерживает семантику копирования;*
4)Копирование приведет к утечке памяти;

№25 Что произойдет, если попытаться скопировать объект класса shared_ptr?
1)Указатель на выделенную память будет увеличен на единицу, и память будет освобождена толькопри удалении последнего указателя на эту память;*
2)Копирование вызовет ошибку компиляции;
3)Копирование запрещено, так как класс shared_ptr не поддерживает семантику копирования;
4)Копирование приведет к утечке памяти;

№26 Какой умный указатель следует использовать, если нужно создать циклические ссылки между объектами?
1)unique_ptr
2)shared_ptr;*
3)weak_ptr;
4)auto_ptr;

№27 Каким образом следует использовать объект класса weak_ptr?
1)Как обычный указатель;
2)Как умный указатель;
3)Для проверки существования объекта, на который указывает shared_ptr;*
4)Для создания циклических ссылок;

№28 Что произойдет, если объект, на который указывает shared_ptr, удаляется вне контекста shared_ptr?
1)Произойдет ошибка времени выполнения;
2)Указатель станет недействительным, но программа продолжит работу без ошибок;*
3)Указатель автоматически переназначится на другой объект;
4)Указатель будет удерживать ссылку на уже удаленный объект;

№29 Какой метод класса shared_ptr следует использовать для проверки, указывает ли указатель на объект?
1)get();
2)count();
3)reset();
4)operator bool();*

№30 Какой метод класса shared_ptr следует использовать для явного освобождения выделенной памяти?
1)get();
2)count();
3)reset();*
4)operator bool();